/**
 * @note This parser header file is generated from a template.
 * Any modifications to this file will be overwritten.
 * Please do not edit this file directly.
 *
 * @note 此文件是从模板生成的。
 * 任何对该文件的修改都将被覆盖。
 * 请不要直接编辑此文件。
 */

#ifndef __JSON_SYNTAX_H__
#define __JSON_SYNTAX_H__

#include "alioth/ast.h"


namespace json {

constexpr alioth::SymbolID COLON = 1;
constexpr alioth::SymbolID COMMA = 2;
constexpr alioth::SymbolID LBRACE = 3;
constexpr alioth::SymbolID RBRACE = 4;
constexpr alioth::SymbolID LBRACKET = 5;
constexpr alioth::SymbolID RBRACKET = 6;
constexpr alioth::SymbolID JNULL = 7;
constexpr alioth::SymbolID TRUE = 8;
constexpr alioth::SymbolID FALSE = 9;
constexpr alioth::SymbolID STRING = 10;
constexpr alioth::SymbolID NUMBER = 11;
constexpr alioth::SymbolID SPACE = 12;

struct Field; // SymbolID = 22; Accepts: [22]
struct Json; // SymbolID = 14; Accepts: [14, 15, 16, 17, 18, 19, 20]




struct Field {
  alioth::AST key() const;
  Json value() const;
  alioth::AST node{};

  operator alioth::AST() const { return node; }
  operator bool() const { return node != nullptr; }
  alioth::ASTNode* operator->() const { return node.get(); }
  alioth::ASTNode& operator*() const { return *node; }
};

struct Json {
  std::vector<Json> array() const;
  alioth::AST boolean() const;
  alioth::AST empty_array() const;
  alioth::AST empty_object() const;
  alioth::AST null() const;
  alioth::AST number() const;
  std::vector<Field> object() const;
  alioth::AST string() const;
  alioth::AST node{};

  operator alioth::AST() const { return node; }
  operator bool() const { return node != nullptr; }
  alioth::ASTNode* operator->() const { return node.get(); }
  alioth::ASTNode& operator*() const { return *node; }
};


}

namespace alioth {
template<>
inline json::Field alioth::ASTNode::As<json::Field>() {
  switch(id) {
    case 22:
    return json::Field{shared_from_this()};
  default:
    return {};
  }
}

template<>
inline json::Json alioth::ASTNode::As<json::Json>() {
  switch(id) {
    case 14:case 15:case 16:case 17:case 18:case 19:case 20:
    return json::Json{shared_from_this()};
  default:
    return {};
  }
}


template<>
inline Syntax SyntaxOf<json::Json>() {
  static auto syntax = []{
    using namespace nlohmann;
    auto lex = Lexicon::Builder("json");
    lex.Define("COLON", R"(:)"_regex);
    
    lex.Define("COMMA", R"(,)"_regex);
    
    lex.Define("LBRACE", R"({)"_regex);
    
    lex.Define("RBRACE", R"(})"_regex);
    
    lex.Define("LBRACKET", R"(\[)"_regex);
    
    lex.Define("RBRACKET", R"(])"_regex);
    
    lex.Define("JNULL", R"(null)"_regex, { "json",  });
    
    lex.Define("TRUE", R"(true)"_regex, { "json",  });
    
    lex.Define("FALSE", R"(false)"_regex, { "json",  });
    
    lex.Define("STRING", R"(\"([^\"\n\\]|\\[^\n])*\")"_regex, { "json",  });
    lex.Annotate("STRING", "tokenize", R"({"type":"string"})"_json);
    
    lex.Define("NUMBER", R"(-?(0|[1-9]\d*)(\.\d+)?([eE][+-]?\d+)?)"_regex, { "json",  });
    lex.Annotate("NUMBER", "tokenize", R"({"type":"number"})"_json);
    
    lex.Define("SPACE", R"(\s+)"_regex);
    
    
    auto syntax = Syntactic::Builder(lex.Build());
    syntax.Ignore("SPACE");
    
    syntax.Formula("json").Symbol("object", "...").Commit();
    syntax.Formula("json").Symbol("array", "...").Commit();
    syntax.Formula("json").Symbol("string", "...").Commit();
    syntax.Formula("json").Symbol("number", "...").Commit();
    syntax.Formula("json").Symbol("boolean", "...").Commit();
    syntax.Formula("json").Symbol("null", "...").Commit();
    syntax.Formula("object").Symbol("LBRACE", "empty_object").Symbol("RBRACE").Commit();
    syntax.Formula("object").Symbol("LBRACE").Symbol("fields", "...").Symbol("RBRACE").Commit();
    syntax.Formula("fields").Symbol("field", "object").Commit();
    syntax.Formula("fields").Symbol("fields", "...").Symbol("COMMA").Symbol("field", "object").Commit();
    syntax.Formula("field").Symbol("STRING", "key").Symbol("COLON").Symbol("json", "value").Commit();
    syntax.Formula("array").Symbol("LBRACKET", "empty_array").Symbol("RBRACKET").Commit();
    syntax.Formula("array").Symbol("LBRACKET").Symbol("elements", "...").Symbol("RBRACKET").Commit();
    syntax.Formula("elements").Symbol("json", "array").Commit();
    syntax.Formula("elements").Symbol("elements", "...").Symbol("COMMA").Symbol("json", "array").Commit();
    syntax.Formula("string").Symbol("STRING", "string").Commit();
    syntax.Formula("number").Symbol("NUMBER", "number").Commit();
    syntax.Formula("boolean").Symbol("TRUE", "boolean").Commit();
    syntax.Formula("boolean").Symbol("FALSE", "boolean").Commit();
    syntax.Formula("null").Symbol("JNULL", "null").Commit();
    
    return syntax.Build();
  }();

  return syntax;
}
}

namespace json {

inline alioth::AST Field::key() const { 
  return node->Attr("key");
}
inline Json Field::value() const {
  return node->Attr("value")->template As<Json>();
}

inline std::vector<Json> Json::array() const { 
  return alioth::generic::collect<alioth::generic::multiple>(
    node->Attrs("array"), 
    [](auto n) {
      return alioth::ViewOf<Json>(n);
    }
  );
}
inline alioth::AST Json::boolean() const { 
  return node->Attr("boolean");
}
inline alioth::AST Json::empty_array() const { 
  return node->Attr("empty_array");
}
inline alioth::AST Json::empty_object() const { 
  return node->Attr("empty_object");
}
inline alioth::AST Json::null() const { 
  return node->Attr("null");
}
inline alioth::AST Json::number() const { 
  return node->Attr("number");
}
inline std::vector<Field> Json::object() const { 
  return alioth::generic::collect<alioth::generic::multiple>(
    node->Attrs("object"), 
    [](auto n) {
      return alioth::ViewOf<Field>(n);
    }
  );
}
inline alioth::AST Json::string() const { 
  return node->Attr("string");
}



}

#endif