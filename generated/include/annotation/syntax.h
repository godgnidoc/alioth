/**
 * @note This parser header file is generated from a template.
 * Any modifications to this file will be overwritten.
 * Please do not edit this file directly.
 *
 * @note 此文件是从模板生成的。
 * 任何对该文件的修改都将被覆盖。
 * 请不要直接编辑此文件。
 */

#ifndef __ANNOTATION_SYNTAX_H__
#define __ANNOTATION_SYNTAX_H__

#include "alioth/ast.h"
#include "json/syntax.h"


namespace annotation {

constexpr alioth::SymbolID COLON = 1;
constexpr alioth::SymbolID COMMA = 2;
constexpr alioth::SymbolID DOT = 3;
constexpr alioth::SymbolID LBRACE = 4;
constexpr alioth::SymbolID RBRACE = 5;
constexpr alioth::SymbolID ID = 6;
constexpr alioth::SymbolID COMMENT = 7;
constexpr alioth::SymbolID SPACE = 8;

struct Annotation; // SymbolID = 10; Accepts: [10]
struct Attribute; // SymbolID = 13; Accepts: [13]


using Json = ::json::Json;


struct Annotation {
  std::vector<Attribute> attributes() const;
  alioth::AST node{};

  operator alioth::AST() const { return node; }
  operator bool() const { return node != nullptr; }
  alioth::ASTNode* operator->() const { return node.get(); }
  alioth::ASTNode& operator*() const { return *node; }
};

struct Attribute {
  alioth::AST key() const;
  alioth::AST of() const;
  Json value() const;
  alioth::AST node{};

  operator alioth::AST() const { return node; }
  operator bool() const { return node != nullptr; }
  alioth::ASTNode* operator->() const { return node.get(); }
  alioth::ASTNode& operator*() const { return *node; }
};


}

namespace alioth {
template<>
inline annotation::Annotation alioth::ASTNode::As<annotation::Annotation>() {
  switch(id) {
    case 10:
    return annotation::Annotation{shared_from_this()};
  default:
    return {};
  }
}

template<>
inline annotation::Attribute alioth::ASTNode::As<annotation::Attribute>() {
  switch(id) {
    case 13:
    return annotation::Attribute{shared_from_this()};
  default:
    return {};
  }
}


template<>
inline Syntax SyntaxOf<annotation::Annotation>() {
  static auto syntax = []{
    using namespace nlohmann;
    auto lex = Lexicon::Builder("annotation");
    lex.Define("COLON", R"(:)"_regex);
    
    lex.Define("COMMA", R"(,)"_regex);
    
    lex.Define("DOT", R"(\.)"_regex);
    
    lex.Define("LBRACE", R"({)"_regex);
    
    lex.Define("RBRACE", R"(})"_regex);
    
    lex.Define("ID", R"([a-zA-Z_]\w*)"_regex);
    
    lex.Define("COMMENT", R"(#[^\n]*\n)"_regex);
    lex.Annotate("COMMENT", "tokenize", R"({"type":"comment"})"_json);
    
    lex.Define("SPACE", R"(\s+)"_regex);
    
    
    auto syntax = Syntactic::Builder(lex.Build());
    syntax.Ignore("COMMENT");
    syntax.Ignore("SPACE");
    
    syntax.Import(::alioth::Syntax<::json::Json>(), "json");
    syntax.Formula("annotation").Symbol("LBRACE").Symbol("attributes", "...").Symbol("RBRACE").Commit();
    syntax.Formula("attributes").Symbol("attribute", "attributes").Commit();
    syntax.Formula("attributes").Symbol("attributes", "...").Symbol("COMMA").Symbol("attribute", "attributes").Commit();
    syntax.Formula("attribute").Symbol("ID", "key").Symbol("COLON").Symbol("json", "value")
      .Annotate("key", "tokenize", R"({"modifier":["modification"],"type":"property"})"_json)
      .Annotate("of", "tokenize", R"({"type":"property"})"_json)
      .Commit();
    syntax.Formula("attribute").Symbol("ID", "of").Symbol("DOT").Symbol("ID", "key").Symbol("COLON").Symbol("json", "value")
      .Annotate("key", "tokenize", R"({"modifier":["modification"],"type":"property"})"_json)
      .Annotate("of", "tokenize", R"({"type":"property"})"_json)
      .Commit();
    
    return syntax.Build();
  }();

  return syntax;
}
}

namespace annotation {

inline std::vector<Attribute> Annotation::attributes() const { 
  return alioth::generic::collect<alioth::generic::multiple>(
    node->Attrs("attributes"), 
    [](auto n) {
      return alioth::ViewOf<Attribute>(n);
    }
  );
}

inline alioth::AST Attribute::key() const { 
  return node->Attr("key");
}
inline alioth::AST Attribute::of() const { 
  return node->Attr("of");
}
inline Json Attribute::value() const {
  return alioth::ViewOf<Json>(node->Attr("value"));
}



}

#endif