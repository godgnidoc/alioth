/**
 * @note This parser header file is generated from a template.
 * Any modifications to this file will be overwritten.
 * Please do not edit this file directly.
 *
 * @note 此文件是从模板生成的。
 * 任何对该文件的修改都将被覆盖。
 * 请不要直接编辑此文件。
 */

#ifndef __ASSIGNMENT_SYNTAX_H__
#define __ASSIGNMENT_SYNTAX_H__

#include "alioth/ast.h"
#include "annotation/syntax.h"


namespace assignment {

constexpr alioth::SymbolID SEMICOLON = 1;
constexpr alioth::SymbolID COMMA = 2;
constexpr alioth::SymbolID DOT = 3;
constexpr alioth::SymbolID ID = 4;
constexpr alioth::SymbolID COMMENT = 5;
constexpr alioth::SymbolID SPACE = 6;

struct Assignment; // SymbolID = 8; Accepts: [8]
struct Selector; // SymbolID = 11; Accepts: [11]


using Annotation = ::annotation::Annotation;


struct Assignment {
  std::vector<Selector> selectors() const;
  alioth::AST node{};

  operator alioth::AST() const { return node; }
  operator bool() const { return node != nullptr; }
  alioth::ASTNode* operator->() const { return node.get(); }
  alioth::ASTNode& operator*() const { return *node; }
};

struct Selector {
  alioth::AST form() const;
  alioth::AST symbol() const;
  alioth::AST node{};

  operator alioth::AST() const { return node; }
  operator bool() const { return node != nullptr; }
  alioth::ASTNode* operator->() const { return node.get(); }
  alioth::ASTNode& operator*() const { return *node; }
};


}

namespace alioth {
template<>
inline assignment::Assignment alioth::ASTNode::As<assignment::Assignment>() {
  switch(id) {
    case 8:
    return assignment::Assignment{shared_from_this()};
  default:
    return {};
  }
}

template<>
inline assignment::Selector alioth::ASTNode::As<assignment::Selector>() {
  switch(id) {
    case 11:
    return assignment::Selector{shared_from_this()};
  default:
    return {};
  }
}


template<>
inline Syntax SyntaxOf<assignment::Assignment>() {
  static auto syntax = []{
    using namespace nlohmann;
    auto lex = Lexicon::Builder("assignment");
    lex.Define("SEMICOLON", R"(;)"_regex);
    
    lex.Define("COMMA", R"(,)"_regex);
    
    lex.Define("DOT", R"(\.)"_regex);
    
    lex.Define("ID", R"([a-zA-Z_]\w*)"_regex);
    
    lex.Define("COMMENT", R"(#[^\n]*\n)"_regex);
    lex.Annotate("COMMENT", "tokenize", R"({"type":"comment"})"_json);
    
    lex.Define("SPACE", R"(\s+)"_regex);
    
    
    auto syntax = Syntactic::Builder(lex.Build());
    syntax.Ignore("COMMENT");
    syntax.Ignore("SPACE");
    
    syntax.Import(::alioth::Syntax<::annotation::Annotation>(), "annotation");
    syntax.Formula("assignment").Symbol("selectors", "...").Symbol("annotation", "...").Commit();
    syntax.Formula("assignment").Symbol("selectors", "...").Symbol("annotation", "...").Symbol("SEMICOLON").Commit();
    syntax.Formula("selectors").Symbol("selector", "selectors").Commit();
    syntax.Formula("selectors").Symbol("selectors", "...").Symbol("COMMA").Symbol("selector", "selectors").Commit();
    syntax.Formula("selector").Symbol("ID", "symbol")
      .Annotate("form", "tokenize", R"({"type":"decorator"})"_json)
      .Annotate("symbol", "tokenize", R"({"type":"class"})"_json)
      .Commit();
    syntax.Formula("selector").Symbol("ID", "symbol").Symbol("DOT").Symbol("ID", "form")
      .Annotate("form", "tokenize", R"({"type":"decorator"})"_json)
      .Annotate("symbol", "tokenize", R"({"type":"class"})"_json)
      .Commit();
    
    return syntax.Build();
  }();

  return syntax;
}
}

namespace assignment {

inline std::vector<Selector> Assignment::selectors() const { 
  return alioth::generic::collect<alioth::generic::multiple>(
    node->Attrs("selectors"), 
    [](auto n) {
      return alioth::ViewOf<Selector>(n);
    }
  );
}

inline alioth::AST Selector::form() const { 
  return node->Attr("form");
}
inline alioth::AST Selector::symbol() const { 
  return node->Attr("symbol");
}



}

#endif