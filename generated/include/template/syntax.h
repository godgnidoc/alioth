/**
 * @note This parser header file is generated from a template.
 * Any modifications to this file will be overwritten.
 * Please do not edit this file directly.
 *
 * @note 此文件是从模板生成的。
 * 任何对该文件的修改都将被覆盖。
 * 请不要直接编辑此文件。
 */

#ifndef __TEMPLATE_SYNTAX_H__
#define __TEMPLATE_SYNTAX_H__

#include "alioth/ast.h"


namespace template {

constexpr alioth::SymbolID TXT = 1;
constexpr alioth::SymbolID COMMENT = 2;
constexpr alioth::SymbolID LOPEN = 3;
constexpr alioth::SymbolID ROPEN = 4;
constexpr alioth::SymbolID LCLOSE = 5;
constexpr alioth::SymbolID RCLOSE = 6;
constexpr alioth::SymbolID RCOMMENT = 7;
constexpr alioth::SymbolID DASH = 8;
constexpr alioth::SymbolID DOUBLEDASH = 9;
constexpr alioth::SymbolID AT = 10;
constexpr alioth::SymbolID OPEN_SUB = 11;
constexpr alioth::SymbolID CLOSE_SUB = 12;
constexpr alioth::SymbolID OPEN_IDX = 13;
constexpr alioth::SymbolID CLOSE_IDX = 14;
constexpr alioth::SymbolID PIPE = 15;
constexpr alioth::SymbolID COMMA = 16;
constexpr alioth::SymbolID DOT = 17;
constexpr alioth::SymbolID EXTENDS = 18;
constexpr alioth::SymbolID OVERWRITE = 19;
constexpr alioth::SymbolID BLOCK = 20;
constexpr alioth::SymbolID CALL = 21;
constexpr alioth::SymbolID WITH = 22;
constexpr alioth::SymbolID AS = 23;
constexpr alioth::SymbolID FOR = 24;
constexpr alioth::SymbolID IN = 25;
constexpr alioth::SymbolID IF = 26;
constexpr alioth::SymbolID ELSE = 27;
constexpr alioth::SymbolID THEN = 28;
constexpr alioth::SymbolID END = 29;
constexpr alioth::SymbolID STRING = 30;
constexpr alioth::SymbolID NUMBER = 31;
constexpr alioth::SymbolID ID = 32;
constexpr alioth::SymbolID SPACE = 33;

struct Block; // SymbolID = 38; Accepts: [38]
struct Branch; // SymbolID = 48; Accepts: [48]
struct Call; // SymbolID = 46; Accepts: [46]
struct Elif; // SymbolID = 62; Accepts: [62]
struct Else; // SymbolID = 61; Accepts: [61]
struct Eval; // SymbolID = 45; Accepts: [45]
struct Expr; // SymbolID = 51; Accepts: [51, 63]
struct Extends; // SymbolID = 36; Accepts: [36]
struct If; // SymbolID = 58; Accepts: [58]
struct Iter; // SymbolID = 47; Accepts: [47]
struct Overwrite; // SymbolID = 41; Accepts: [41]
struct Template; // SymbolID = 35; Accepts: [35, 37]
struct Text; // SymbolID = 44; Accepts: [44]
struct This; // SymbolID = 53; Accepts: [53]


struct Block {
  alioth::AST block() const;
  std::vector<alioth::AST> fragments() const;
  alioth::AST trim_start() const;
  alioth::AST node{};

  operator alioth::AST() const { return node; }
  operator bool() const { return node != nullptr; }
  alioth::ASTNode* operator->() const { return node.get(); }
  alioth::ASTNode& operator*() const { return *node; }
};

struct Branch {
  std::vector<alioth::AST> branch() const;
  alioth::AST trim_end() const;
  alioth::AST node{};

  operator alioth::AST() const { return node; }
  operator bool() const { return node != nullptr; }
  alioth::ASTNode* operator->() const { return node.get(); }
  alioth::ASTNode& operator*() const { return *node; }
};

struct Call {
  alioth::AST call() const;
  Expr model() const;
  std::vector<This> these() const;
  alioth::AST trim_end() const;
  alioth::AST trim_start() const;
  alioth::AST node{};

  operator alioth::AST() const { return node; }
  operator bool() const { return node != nullptr; }
  alioth::ASTNode* operator->() const { return node.get(); }
  alioth::ASTNode& operator*() const { return *node; }
};

struct Elif {
  Expr cond() const;
  std::vector<alioth::AST> fragments() const;
  alioth::AST trim_end() const;
  alioth::AST trim_start() const;
  alioth::AST node{};

  operator alioth::AST() const { return node; }
  operator bool() const { return node != nullptr; }
  alioth::ASTNode* operator->() const { return node.get(); }
  alioth::ASTNode& operator*() const { return *node; }
};

struct Else {
  std::vector<alioth::AST> fragments() const;
  alioth::AST trim_end() const;
  alioth::AST trim_start() const;
  alioth::AST node{};

  operator alioth::AST() const { return node; }
  operator bool() const { return node != nullptr; }
  alioth::ASTNode* operator->() const { return node.get(); }
  alioth::ASTNode& operator*() const { return *node; }
};

struct Eval {
  Expr eval() const;
  alioth::AST trim_end() const;
  alioth::AST trim_start() const;
  alioth::AST node{};

  operator alioth::AST() const { return node; }
  operator bool() const { return node != nullptr; }
  alioth::ASTNode* operator->() const { return node.get(); }
  alioth::ASTNode& operator*() const { return *node; }
};

struct Expr {
  struct Field;
  struct Index;
  struct Invoke;
  struct Number;
  struct Pipe;
  struct String;
  struct Var;
  
  
  alioth::AST node{};

  operator alioth::AST() const { return node; }
  operator bool() const { return node != nullptr; }
  alioth::ASTNode* operator->() const { return node.get(); }
  alioth::ASTNode& operator*() const { return *node; }
};
struct Expr::Field: public Expr {
  using Expr::Expr;

  alioth::AST field() const;
  Expr of() const;
};
struct Expr::Index: public Expr {
  using Expr::Expr;

  Expr index() const;
  Expr of() const;
};
struct Expr::Invoke: public Expr {
  using Expr::Expr;

  Expr invoke() const;
  std::vector<Expr> params() const;
};
struct Expr::Number: public Expr {
  using Expr::Expr;

  alioth::AST number() const;
};
struct Expr::Pipe: public Expr {
  using Expr::Expr;

  Expr expr() const;
  Expr pipe() const;
};
struct Expr::String: public Expr {
  using Expr::Expr;

  alioth::AST string() const;
};
struct Expr::Var: public Expr {
  using Expr::Expr;

  alioth::AST anchor() const;
  alioth::AST variable() const;
};


struct Extends {
  std::vector<alioth::AST> drop() const;
  alioth::AST extends() const;
  std::vector<Overwrite> overwrites() const;
  alioth::AST node{};

  operator alioth::AST() const { return node; }
  operator bool() const { return node != nullptr; }
  alioth::ASTNode* operator->() const { return node.get(); }
  alioth::ASTNode& operator*() const { return *node; }
};

struct If {
  Expr cond() const;
  std::vector<alioth::AST> fragments() const;
  alioth::AST trim_start() const;
  alioth::AST node{};

  operator alioth::AST() const { return node; }
  operator bool() const { return node != nullptr; }
  alioth::ASTNode* operator->() const { return node.get(); }
  alioth::ASTNode& operator*() const { return *node; }
};

struct Iter {
  alioth::AST anchor() const;
  std::vector<alioth::AST> fragments() const;
  alioth::AST index() const;
  Expr iter() const;
  alioth::AST key() const;
  alioth::AST trim_end() const;
  alioth::AST trim_start() const;
  alioth::AST value() const;
  alioth::AST node{};

  operator alioth::AST() const { return node; }
  operator bool() const { return node != nullptr; }
  alioth::ASTNode* operator->() const { return node.get(); }
  alioth::ASTNode& operator*() const { return *node; }
};

struct Overwrite {
  std::vector<alioth::AST> fragments() const;
  alioth::AST overwrite() const;
  alioth::AST trim_start() const;
  alioth::AST node{};

  operator alioth::AST() const { return node; }
  operator bool() const { return node != nullptr; }
  alioth::ASTNode* operator->() const { return node.get(); }
  alioth::ASTNode& operator*() const { return *node; }
};

struct Template {
  std::vector<alioth::AST> fragments() const;
  alioth::AST node{};

  operator alioth::AST() const { return node; }
  operator bool() const { return node != nullptr; }
  alioth::ASTNode* operator->() const { return node.get(); }
  alioth::ASTNode& operator*() const { return *node; }
};

struct Text {
  alioth::AST text() const;
  alioth::AST node{};

  operator alioth::AST() const { return node; }
  operator bool() const { return node != nullptr; }
  alioth::ASTNode* operator->() const { return node.get(); }
  alioth::ASTNode& operator*() const { return *node; }
};

struct This {
  alioth::AST key() const;
  Expr value() const;
  alioth::AST node{};

  operator alioth::AST() const { return node; }
  operator bool() const { return node != nullptr; }
  alioth::ASTNode* operator->() const { return node.get(); }
  alioth::ASTNode& operator*() const { return *node; }
};


}

namespace alioth {
template<>
inline template::Block alioth::ASTNode::As<template::Block>() {
  switch(id) {
    case 38:
    return template::Block{shared_from_this()};
  default:
    return {};
  }
}

template<>
inline template::Branch alioth::ASTNode::As<template::Branch>() {
  switch(id) {
    case 48:
    return template::Branch{shared_from_this()};
  default:
    return {};
  }
}

template<>
inline template::Call alioth::ASTNode::As<template::Call>() {
  switch(id) {
    case 46:
    return template::Call{shared_from_this()};
  default:
    return {};
  }
}

template<>
inline template::Elif alioth::ASTNode::As<template::Elif>() {
  switch(id) {
    case 62:
    return template::Elif{shared_from_this()};
  default:
    return {};
  }
}

template<>
inline template::Else alioth::ASTNode::As<template::Else>() {
  switch(id) {
    case 61:
    return template::Else{shared_from_this()};
  default:
    return {};
  }
}

template<>
inline template::Eval alioth::ASTNode::As<template::Eval>() {
  switch(id) {
    case 45:
    return template::Eval{shared_from_this()};
  default:
    return {};
  }
}

template<>
inline template::Expr alioth::ASTNode::As<template::Expr>() {
  switch(id) {
    case 51:case 63:
    return template::Expr{shared_from_this()};
  default:
    return {};
  }
}
template<>
inline template::Expr::Field alioth::ASTNode::As<template::Expr::Field>() {
  switch(OriginFormula()) {
    case 92:
    return template::Expr::Field{shared_from_this()};
  default:
    return {};
  }
}
template<>
inline template::Expr::Index alioth::ASTNode::As<template::Expr::Index>() {
  switch(OriginFormula()) {
    case 93:
    return template::Expr::Index{shared_from_this()};
  default:
    return {};
  }
}
template<>
inline template::Expr::Invoke alioth::ASTNode::As<template::Expr::Invoke>() {
  switch(OriginFormula()) {
    case 90:case 91:
    return template::Expr::Invoke{shared_from_this()};
  default:
    return {};
  }
}
template<>
inline template::Expr::Number alioth::ASTNode::As<template::Expr::Number>() {
  switch(OriginFormula()) {
    case 89:
    return template::Expr::Number{shared_from_this()};
  default:
    return {};
  }
}
template<>
inline template::Expr::Pipe alioth::ASTNode::As<template::Expr::Pipe>() {
  switch(OriginFormula()) {
    case 85:
    return template::Expr::Pipe{shared_from_this()};
  default:
    return {};
  }
}
template<>
inline template::Expr::String alioth::ASTNode::As<template::Expr::String>() {
  switch(OriginFormula()) {
    case 88:
    return template::Expr::String{shared_from_this()};
  default:
    return {};
  }
}
template<>
inline template::Expr::Var alioth::ASTNode::As<template::Expr::Var>() {
  switch(OriginFormula()) {
    case 86:case 87:
    return template::Expr::Var{shared_from_this()};
  default:
    return {};
  }
}


template<>
inline template::Extends alioth::ASTNode::As<template::Extends>() {
  switch(id) {
    case 36:
    return template::Extends{shared_from_this()};
  default:
    return {};
  }
}

template<>
inline template::If alioth::ASTNode::As<template::If>() {
  switch(id) {
    case 58:
    return template::If{shared_from_this()};
  default:
    return {};
  }
}

template<>
inline template::Iter alioth::ASTNode::As<template::Iter>() {
  switch(id) {
    case 47:
    return template::Iter{shared_from_this()};
  default:
    return {};
  }
}

template<>
inline template::Overwrite alioth::ASTNode::As<template::Overwrite>() {
  switch(id) {
    case 41:
    return template::Overwrite{shared_from_this()};
  default:
    return {};
  }
}

template<>
inline template::Template alioth::ASTNode::As<template::Template>() {
  switch(id) {
    case 35:case 37:
    return template::Template{shared_from_this()};
  default:
    return {};
  }
}

template<>
inline template::Text alioth::ASTNode::As<template::Text>() {
  switch(id) {
    case 44:
    return template::Text{shared_from_this()};
  default:
    return {};
  }
}

template<>
inline template::This alioth::ASTNode::As<template::This>() {
  switch(id) {
    case 53:
    return template::This{shared_from_this()};
  default:
    return {};
  }
}


template<>
inline Syntax SyntaxOf<template::Template>() {
  static auto syntax = []{
    using namespace alioth;
    using namespace nlohmann;
    auto lex = Lexicon::Builder("template");
    lex.Define("TXT", R"({|[^{]+)"_regex, { "template",  });
    lex.Annotate("TXT", "tokenize", R"({"type":"string"})"_json);
    
    lex.Define("COMMENT", R"(}|[^}]+)"_regex, { "comment",  });
    lex.Annotate("COMMENT", "tokenize", R"({"type":"comment"})"_json);
    
    lex.Define("LOPEN", R"({{)"_regex, { "template",  });
    lex.Annotate("LOPEN", "tokenize", R"({"type":"operator"})"_json);
    
    lex.Define("ROPEN", R"(}})"_regex, { "ropen",  });
    lex.Annotate("ROPEN", "tokenize", R"({"type":"operator"})"_json);
    
    lex.Define("LCLOSE", R"({{)"_regex, { "lclose",  });
    lex.Annotate("LCLOSE", "tokenize", R"({"type":"operator"})"_json);
    
    lex.Define("RCLOSE", R"(}})"_regex, { "rclose",  });
    lex.Annotate("RCLOSE", "tokenize", R"({"type":"operator"})"_json);
    
    lex.Define("RCOMMENT", R"(}})"_regex, { "comment",  });
    lex.Annotate("RCOMMENT", "tokenize", R"({"type":"operator"})"_json);
    
    lex.Define("DASH", R"(-)"_regex, { "ctrl",  });
    lex.Annotate("DASH", "tokenize", R"({"type":"operator"})"_json);
    
    lex.Define("DOUBLEDASH", R"(--)"_regex, { "ctrl",  });
    lex.Annotate("DOUBLEDASH", "tokenize", R"({"type":"comment"})"_json);
    
    lex.Define("AT", R"(@)"_regex, { "ctrl",  });
    lex.Annotate("AT", "tokenize", R"({"type":"operator"})"_json);
    
    lex.Define("OPEN_SUB", R"(\()"_regex, { "expr",  });
    lex.Annotate("OPEN_SUB", "tokenize", R"({"type":"operator"})"_json);
    
    lex.Define("CLOSE_SUB", R"(\))"_regex, { "expr",  });
    lex.Annotate("CLOSE_SUB", "tokenize", R"({"type":"operator"})"_json);
    
    lex.Define("OPEN_IDX", R"(\[)"_regex, { "expr",  });
    lex.Annotate("OPEN_IDX", "tokenize", R"({"type":"operator"})"_json);
    
    lex.Define("CLOSE_IDX", R"(])"_regex, { "expr",  });
    lex.Annotate("CLOSE_IDX", "tokenize", R"({"type":"operator"})"_json);
    
    lex.Define("PIPE", R"(\|)"_regex, { "expr",  });
    lex.Annotate("PIPE", "tokenize", R"({"type":"operator"})"_json);
    
    lex.Define("COMMA", R"(,)"_regex, { "expr",  });
    lex.Annotate("COMMA", "tokenize", R"({"type":"operator"})"_json);
    
    lex.Define("DOT", R"(\.)"_regex, { "expr",  });
    lex.Annotate("DOT", "tokenize", R"({"type":"operator"})"_json);
    
    lex.Define("EXTENDS", R"(extends)"_regex, { "ctrl",  });
    lex.Annotate("EXTENDS", "tokenize", R"({"type":"keyword"})"_json);
    
    lex.Define("OVERWRITE", R"(overwrite)"_regex, { "ctrl",  });
    lex.Annotate("OVERWRITE", "tokenize", R"({"type":"keyword"})"_json);
    
    lex.Define("BLOCK", R"(block)"_regex, { "ctrl",  });
    lex.Annotate("BLOCK", "tokenize", R"({"type":"keyword"})"_json);
    
    lex.Define("CALL", R"(call)"_regex, { "ctrl",  });
    lex.Annotate("CALL", "tokenize", R"({"type":"keyword"})"_json);
    
    lex.Define("WITH", R"(with)"_regex, { "ctrl",  });
    lex.Annotate("WITH", "tokenize", R"({"type":"keyword"})"_json);
    
    lex.Define("AS", R"(as)"_regex, { "ctrl",  });
    lex.Annotate("AS", "tokenize", R"({"type":"keyword"})"_json);
    
    lex.Define("FOR", R"(for)"_regex, { "ctrl",  });
    lex.Annotate("FOR", "tokenize", R"({"type":"keyword"})"_json);
    
    lex.Define("IN", R"(in)"_regex, { "ctrl",  });
    lex.Annotate("IN", "tokenize", R"({"type":"keyword"})"_json);
    
    lex.Define("IF", R"(if)"_regex, { "ctrl",  });
    lex.Annotate("IF", "tokenize", R"({"type":"keyword"})"_json);
    
    lex.Define("ELSE", R"(else)"_regex, { "ctrl",  });
    lex.Annotate("ELSE", "tokenize", R"({"type":"keyword"})"_json);
    
    lex.Define("THEN", R"(then)"_regex, { "ctrl",  });
    lex.Annotate("THEN", "tokenize", R"({"type":"keyword"})"_json);
    
    lex.Define("END", R"(end)"_regex, { "ctrl",  });
    lex.Annotate("END", "tokenize", R"({"type":"keyword"})"_json);
    
    lex.Define("STRING", R"(\"([^\"\n\\]|\\[^\n])*\")"_regex, { "expr",  });
    lex.Annotate("STRING", "tokenize", R"({"type":"string"})"_json);
    
    lex.Define("NUMBER", R"(-?(0|[1-9]\d*)(\.\d+)?([eE][+-]?\d+)?)"_regex, { "expr",  });
    lex.Annotate("NUMBER", "tokenize", R"({"type":"number"})"_json);
    
    lex.Define("ID", R"([a-zA-Z_]\w*)"_regex, { "expr",  });
    lex.Annotate("ID", "tokenize", R"({"type":"variable"})"_json);
    
    lex.Define("SPACE", R"(\s+)"_regex, { "ropen", "rclose", "ctrl", "expr",  });
    
    
    auto syntax = Syntactic::Builder(lex.Build());
    syntax.Ignore("SPACE");
    
    syntax.Formula("template").Symbol("extends", "fragments").Commit();
    syntax.Formula("template").Symbol("fragments", "...").Commit();
    syntax.Formula("block").Symbol("open_block", "...").Symbol("fragments", "...").Symbol("close_block").Commit();
    syntax.Formula("open_block").Symbol("LOPEN").Symbol("BLOCK").Symbol("ID", "block").Symbol("ROPEN")
      .Annotate("block", "tokenize", R"({"modifier":["definition"],"type":"class"})"_json)
      .Commit();
    syntax.Formula("open_block").Symbol("LOPEN").Symbol("BLOCK").Symbol("ID", "block").Symbol("DASH", "trim_start").Symbol("ROPEN")
      .Annotate("block", "tokenize", R"({"modifier":["definition"],"type":"class"})"_json)
      .Commit();
    syntax.Formula("close_block").Symbol("LCLOSE").Symbol("END").Symbol("BLOCK").Symbol("RCLOSE").Commit();
    syntax.Formula("close_block").Symbol("LCLOSE").Symbol("DASH", "trim_end").Symbol("END").Symbol("BLOCK").Symbol("RCLOSE").Commit();
    syntax.Formula("extends").Symbol("LOPEN").Symbol("EXTENDS").Symbol("STRING", "extends").Symbol("ROPEN").Commit();
    syntax.Formula("extends").Symbol("SPACE").Symbol("LOPEN").Symbol("EXTENDS").Symbol("STRING", "extends").Symbol("ROPEN").Commit();
    syntax.Formula("extends").Symbol("extends", "...").Symbol("overwrite", "overwrites").Commit();
    syntax.Formula("extends").Symbol("extends", "...").Symbol("TXT", "drop")
      .Annotate("drop", "tokenize", R"({"type":"comment"})"_json)
      .Commit();
    syntax.Formula("overwrite").Symbol("open_overwrite", "...").Symbol("fragments", "...").Symbol("close_overwrite").Commit();
    syntax.Formula("open_overwrite").Symbol("LOPEN").Symbol("OVERWRITE").Symbol("ID", "overwrite").Symbol("ROPEN")
      .Annotate("overwrite", "tokenize", R"({"type":"class"})"_json)
      .Commit();
    syntax.Formula("open_overwrite").Symbol("LOPEN").Symbol("OVERWRITE").Symbol("ID", "overwrite").Symbol("DASH", "trim_start").Symbol("ROPEN")
      .Annotate("overwrite", "tokenize", R"({"type":"class"})"_json)
      .Commit();
    syntax.Formula("close_overwrite").Symbol("LCLOSE").Symbol("END").Symbol("OVERWRITE").Symbol("RCLOSE").Commit();
    syntax.Formula("close_overwrite").Symbol("LCLOSE").Symbol("DASH", "trim_end").Symbol("END").Symbol("OVERWRITE").Symbol("RCLOSE").Commit();
    syntax.Formula("fragments").Symbol("text", "fragments").Commit();
    syntax.Formula("fragments").Symbol("fragments", "...").Symbol("text", "fragments").Commit();
    syntax.Formula("fragments").Symbol("eval", "fragments").Commit();
    syntax.Formula("fragments").Symbol("fragments", "...").Symbol("eval", "fragments").Commit();
    syntax.Formula("fragments").Symbol("call", "fragments").Commit();
    syntax.Formula("fragments").Symbol("fragments", "...").Symbol("call", "fragments").Commit();
    syntax.Formula("fragments").Symbol("iter", "fragments").Commit();
    syntax.Formula("fragments").Symbol("fragments", "...").Symbol("iter", "fragments").Commit();
    syntax.Formula("fragments").Symbol("branch", "fragments").Commit();
    syntax.Formula("fragments").Symbol("fragments", "...").Symbol("branch", "fragments").Commit();
    syntax.Formula("fragments").Symbol("block", "fragments").Commit();
    syntax.Formula("fragments").Symbol("fragments", "...").Symbol("block", "fragments").Commit();
    syntax.Formula("fragments").Symbol("comment").Commit();
    syntax.Formula("fragments").Symbol("fragments", "...").Symbol("comment").Commit();
    syntax.Formula("comment").Symbol("LOPEN").Symbol("DOUBLEDASH").Symbol("RCOMMENT").Commit();
    syntax.Formula("comment").Symbol("LOPEN").Symbol("DOUBLEDASH").Symbol("comments", "...").Symbol("RCOMMENT").Commit();
    syntax.Formula("comments").Symbol("COMMENT").Commit();
    syntax.Formula("comments").Symbol("comments", "...").Symbol("COMMENT").Commit();
    syntax.Formula("text").Symbol("TXT", "text").Commit();
    syntax.Formula("eval").Symbol("LOPEN").Symbol("expr", "eval").Symbol("ROPEN").Commit();
    syntax.Formula("eval").Symbol("LOPEN").Symbol("DASH", "trim_start").Symbol("expr", "eval").Symbol("ROPEN").Commit();
    syntax.Formula("eval").Symbol("LOPEN").Symbol("expr", "eval").Symbol("DASH", "trim_end").Symbol("ROPEN").Commit();
    syntax.Formula("eval").Symbol("LOPEN").Symbol("DASH", "trim_start").Symbol("expr", "eval").Symbol("DASH", "trim_end").Symbol("ROPEN").Commit();
    syntax.Formula("call").Symbol("LOPEN").Symbol("CALL").Symbol("STRING", "call").Symbol("ROPEN").Commit();
    syntax.Formula("call").Symbol("LOPEN").Symbol("DASH", "trim_start").Symbol("CALL").Symbol("STRING", "call").Symbol("ROPEN").Commit();
    syntax.Formula("call").Symbol("LOPEN").Symbol("CALL").Symbol("STRING", "call").Symbol("DASH", "trim_end").Symbol("ROPEN").Commit();
    syntax.Formula("call").Symbol("LOPEN").Symbol("DASH", "trim_start").Symbol("CALL").Symbol("STRING", "call").Symbol("DASH", "trim_end").Symbol("ROPEN").Commit();
    syntax.Formula("call").Symbol("LOPEN").Symbol("CALL").Symbol("STRING", "call").Symbol("WITH").Symbol("expr", "model").Symbol("ROPEN").Commit();
    syntax.Formula("call").Symbol("LOPEN").Symbol("DASH", "trim_start").Symbol("CALL").Symbol("STRING", "call").Symbol("WITH").Symbol("expr", "model").Symbol("ROPEN").Commit();
    syntax.Formula("call").Symbol("LOPEN").Symbol("CALL").Symbol("STRING", "call").Symbol("WITH").Symbol("expr", "model").Symbol("DASH", "trim_end").Symbol("ROPEN").Commit();
    syntax.Formula("call").Symbol("LOPEN").Symbol("DASH", "trim_start").Symbol("CALL").Symbol("STRING", "call").Symbol("WITH").Symbol("expr", "model").Symbol("DASH", "trim_end").Symbol("ROPEN").Commit();
    syntax.Formula("call").Symbol("LOPEN").Symbol("CALL").Symbol("STRING", "call").Symbol("WITH").Symbol("these", "...").Symbol("ROPEN").Commit();
    syntax.Formula("call").Symbol("LOPEN").Symbol("DASH", "trim_start").Symbol("CALL").Symbol("STRING", "call").Symbol("WITH").Symbol("these", "...").Symbol("ROPEN").Commit();
    syntax.Formula("call").Symbol("LOPEN").Symbol("CALL").Symbol("STRING", "call").Symbol("WITH").Symbol("these", "...").Symbol("DASH", "trim_end").Symbol("ROPEN").Commit();
    syntax.Formula("call").Symbol("LOPEN").Symbol("DASH", "trim_start").Symbol("CALL").Symbol("STRING", "call").Symbol("WITH").Symbol("these", "...").Symbol("DASH", "trim_end").Symbol("ROPEN").Commit();
    syntax.Formula("these").Symbol("this", "these").Commit();
    syntax.Formula("these").Symbol("these", "...").Symbol("COMMA").Symbol("this", "these").Commit();
    syntax.Formula("this").Symbol("expr", "value").Symbol("AS").Symbol("ID", "key").Commit();
    syntax.Formula("iter").Symbol("open_iter", "...").Symbol("fragments", "...").Symbol("close_iter", "...").Commit();
    syntax.Formula("open_iter").Symbol("LOPEN").Symbol("FOR").Symbol("iter_vars", "...").Symbol("IN").Symbol("expr", "iter").Symbol("ROPEN").Commit();
    syntax.Formula("open_iter").Symbol("LOPEN").Symbol("FOR").Symbol("anchor", "...").Symbol("iter_vars", "...").Symbol("IN").Symbol("expr", "iter").Symbol("ROPEN").Commit();
    syntax.Formula("open_iter").Symbol("LOPEN").Symbol("FOR").Symbol("iter_vars", "...").Symbol("IN").Symbol("expr", "iter").Symbol("DASH", "trim_start").Symbol("ROPEN").Commit();
    syntax.Formula("open_iter").Symbol("LOPEN").Symbol("FOR").Symbol("anchor", "...").Symbol("iter_vars", "...").Symbol("IN").Symbol("expr", "iter").Symbol("DASH", "trim_start").Symbol("ROPEN").Commit();
    syntax.Formula("anchor").Symbol("AT").Symbol("ID", "anchor")
      .Annotate("anchor", "tokenize", R"({"modifier":["definition"],"type":"label"})"_json)
      .Commit();
    syntax.Formula("close_iter").Symbol("LCLOSE").Symbol("END").Symbol("FOR").Symbol("RCLOSE").Commit();
    syntax.Formula("close_iter").Symbol("LCLOSE").Symbol("DASH", "trim_end").Symbol("END").Symbol("FOR").Symbol("RCLOSE").Commit();
    syntax.Formula("iter_vars").Symbol("ID", "value")
      .Annotate("index", "tokenize", R"({"modifier":["definition"]})"_json)
      .Annotate("key", "tokenize", R"({"modifier":["definition"]})"_json)
      .Annotate("value", "tokenize", R"({"modifier":["definition"]})"_json)
      .Commit();
    syntax.Formula("iter_vars").Symbol("ID", "value").Symbol("COMMA").Symbol("ID", "key")
      .Annotate("index", "tokenize", R"({"modifier":["definition"]})"_json)
      .Annotate("key", "tokenize", R"({"modifier":["definition"]})"_json)
      .Annotate("value", "tokenize", R"({"modifier":["definition"]})"_json)
      .Commit();
    syntax.Formula("iter_vars").Symbol("ID", "value").Symbol("COMMA").Symbol("ID", "key").Symbol("COMMA").Symbol("ID", "index")
      .Annotate("index", "tokenize", R"({"modifier":["definition"]})"_json)
      .Annotate("key", "tokenize", R"({"modifier":["definition"]})"_json)
      .Annotate("value", "tokenize", R"({"modifier":["definition"]})"_json)
      .Commit();
    syntax.Formula("branch").Symbol("if", "branch").Symbol("close_branch", "...").Commit();
    syntax.Formula("branch").Symbol("if", "branch").Symbol("elifs", "...").Symbol("close_branch", "...").Commit();
    syntax.Formula("branch").Symbol("if", "branch").Symbol("else", "branch").Symbol("close_branch", "...").Commit();
    syntax.Formula("branch").Symbol("if", "branch").Symbol("elifs", "...").Symbol("else", "branch").Symbol("close_branch", "...").Commit();
    syntax.Formula("if").Symbol("LOPEN").Symbol("IF").Symbol("expr", "cond").Symbol("ROPEN").Symbol("fragments", "...").Commit();
    syntax.Formula("if").Symbol("LOPEN").Symbol("IF").Symbol("expr", "cond").Symbol("DASH", "trim_start").Symbol("ROPEN").Symbol("fragments", "...").Commit();
    syntax.Formula("elifs").Symbol("elif", "branch").Commit();
    syntax.Formula("elifs").Symbol("elifs", "...").Symbol("elif", "branch").Commit();
    syntax.Formula("elif").Symbol("LCLOSE").Symbol("ELSE").Symbol("IF").Symbol("expr", "cond").Symbol("RCLOSE").Symbol("fragments", "...").Commit();
    syntax.Formula("elif").Symbol("LCLOSE").Symbol("DASH", "trim_end").Symbol("ELSE").Symbol("IF").Symbol("expr", "cond").Symbol("RCLOSE").Symbol("fragments", "...").Commit();
    syntax.Formula("elif").Symbol("LCLOSE").Symbol("ELSE").Symbol("IF").Symbol("expr", "cond").Symbol("DASH", "trim_start").Symbol("RCLOSE").Symbol("fragments", "...").Commit();
    syntax.Formula("elif").Symbol("LCLOSE").Symbol("DASH", "trim_end").Symbol("ELSE").Symbol("IF").Symbol("expr", "cond").Symbol("DASH", "trim_start").Symbol("RCLOSE").Symbol("fragments", "...").Commit();
    syntax.Formula("else").Symbol("LCLOSE").Symbol("ELSE").Symbol("THEN").Symbol("RCLOSE").Symbol("fragments", "...").Commit();
    syntax.Formula("else").Symbol("LCLOSE").Symbol("DASH", "trim_end").Symbol("ELSE").Symbol("THEN").Symbol("RCLOSE").Symbol("fragments", "...").Commit();
    syntax.Formula("else").Symbol("LCLOSE").Symbol("ELSE").Symbol("THEN").Symbol("DASH", "trim_start").Symbol("RCLOSE").Symbol("fragments", "...").Commit();
    syntax.Formula("else").Symbol("LCLOSE").Symbol("DASH", "trim_end").Symbol("ELSE").Symbol("THEN").Symbol("DASH", "trim_start").Symbol("RCLOSE").Symbol("fragments", "...").Commit();
    syntax.Formula("close_branch").Symbol("LCLOSE").Symbol("END").Symbol("IF").Symbol("RCLOSE").Commit();
    syntax.Formula("close_branch").Symbol("LCLOSE").Symbol("DASH", "trim_end").Symbol("END").Symbol("IF").Symbol("RCLOSE").Commit();
    syntax.Formula("expr").Symbol("prim", "...").Commit();
    syntax.Formula("expr", "pipe").Symbol("expr", "expr").Symbol("PIPE").Symbol("prim", "pipe").Commit();
    syntax.Formula("prim", "var").Symbol("ID", "variable").Commit();
    syntax.Formula("prim", "var").Symbol("ID", "variable").Symbol("AT").Symbol("ID", "anchor")
      .Annotate("anchor", "tokenize", R"({"type":"label"})"_json)
      .Commit();
    syntax.Formula("prim", "string").Symbol("STRING", "string").Commit();
    syntax.Formula("prim", "number").Symbol("NUMBER", "number").Commit();
    syntax.Formula("prim", "invoke").Symbol("prim", "invoke").Symbol("OPEN_SUB").Symbol("CLOSE_SUB").Commit();
    syntax.Formula("prim", "invoke").Symbol("prim", "invoke").Symbol("OPEN_SUB").Symbol("params", "...").Symbol("CLOSE_SUB").Commit();
    syntax.Formula("prim", "field").Symbol("prim", "of").Symbol("DOT").Symbol("ID", "field")
      .Annotate("field", "tokenize", R"({"type":"property"})"_json)
      .Commit();
    syntax.Formula("prim", "index").Symbol("prim", "of").Symbol("OPEN_IDX").Symbol("expr", "index").Symbol("CLOSE_IDX").Commit();
    syntax.Formula("params").Symbol("expr", "params").Commit();
    syntax.Formula("params").Symbol("params", "...").Symbol("COMMA").Symbol("expr", "params").Commit();
    
    return syntax.Build();
  }();

  return syntax;
}
}

namespace template {

inline alioth::AST Block::block() const { return node->Attr("block"); }
inline std::vector<alioth::AST> Block::fragments() const { return node->Attrs("fragments"); }
inline alioth::AST Block::trim_start() const { return node->Attr("trim_start"); }

inline std::vector<alioth::AST> Branch::branch() const { return node->Attrs("branch"); }
inline alioth::AST Branch::trim_end() const { return node->Attr("trim_end"); }

inline alioth::AST Call::call() const { return node->Attr("call"); }
inline Expr Call::model() const { return node->Attr("model")->template As<Expr>(); }
inline std::vector<This> Call::these() const { return alioth::generic::collect<alioth::generic::multiple>(node->Attrs("these"), [](auto n) { return n->template As<This>(); }); }
inline alioth::AST Call::trim_end() const { return node->Attr("trim_end"); }
inline alioth::AST Call::trim_start() const { return node->Attr("trim_start"); }

inline Expr Elif::cond() const { return node->Attr("cond")->template As<Expr>(); }
inline std::vector<alioth::AST> Elif::fragments() const { return node->Attrs("fragments"); }
inline alioth::AST Elif::trim_end() const { return node->Attr("trim_end"); }
inline alioth::AST Elif::trim_start() const { return node->Attr("trim_start"); }

inline std::vector<alioth::AST> Else::fragments() const { return node->Attrs("fragments"); }
inline alioth::AST Else::trim_end() const { return node->Attr("trim_end"); }
inline alioth::AST Else::trim_start() const { return node->Attr("trim_start"); }

inline Expr Eval::eval() const { return node->Attr("eval")->template As<Expr>(); }
inline alioth::AST Eval::trim_end() const { return node->Attr("trim_end"); }
inline alioth::AST Eval::trim_start() const { return node->Attr("trim_start"); }

inline alioth::AST Expr::anchor() const { return node->Attr("anchor"); }
inline Expr Expr::expr() const { return node->Attr("expr")->template As<Expr>(); }
inline alioth::AST Expr::field() const { return node->Attr("field"); }
inline Expr Expr::index() const { return node->Attr("index")->template As<Expr>(); }
inline Expr Expr::invoke() const { return node->Attr("invoke")->template As<Expr>(); }
inline alioth::AST Expr::number() const { return node->Attr("number"); }
inline Expr Expr::of() const { return node->Attr("of")->template As<Expr>(); }
inline std::vector<Expr> Expr::params() const { return alioth::generic::collect<alioth::generic::multiple>(node->Attrs("params"), [](auto n) { return n->template As<Expr>(); }); }
inline Expr Expr::pipe() const { return node->Attr("pipe")->template As<Expr>(); }
inline alioth::AST Expr::string() const { return node->Attr("string"); }
inline alioth::AST Expr::variable() const { return node->Attr("variable"); }
inline alioth::AST Expr::Field::field() const { return node->Attr("field"); }
inline Expr Expr::Field::of() const { return node->Attr("of")->template As<Expr>(); }
inline Expr Expr::Index::index() const { return node->Attr("index")->template As<Expr>(); }
inline Expr Expr::Index::of() const { return node->Attr("of")->template As<Expr>(); }
inline Expr Expr::Invoke::invoke() const { return node->Attr("invoke")->template As<Expr>(); }
inline std::vector<Expr> Expr::Invoke::params() const { return alioth::generic::collect<alioth::generic::multiple>(node->Attrs("params"), [](auto n) { return n->template As<Expr>(); }); }
inline alioth::AST Expr::Number::number() const { return node->Attr("number"); }
inline Expr Expr::Pipe::expr() const { return node->Attr("expr")->template As<Expr>(); }
inline Expr Expr::Pipe::pipe() const { return node->Attr("pipe")->template As<Expr>(); }
inline alioth::AST Expr::String::string() const { return node->Attr("string"); }
inline alioth::AST Expr::Var::anchor() const { return node->Attr("anchor"); }
inline alioth::AST Expr::Var::variable() const { return node->Attr("variable"); }


inline std::vector<alioth::AST> Extends::drop() const { return node->Attrs("drop"); }
inline alioth::AST Extends::extends() const { return node->Attr("extends"); }
inline std::vector<Overwrite> Extends::overwrites() const { return alioth::generic::collect<alioth::generic::multiple>(node->Attrs("overwrites"), [](auto n) { return n->template As<Overwrite>(); }); }

inline Expr If::cond() const { return node->Attr("cond")->template As<Expr>(); }
inline std::vector<alioth::AST> If::fragments() const { return node->Attrs("fragments"); }
inline alioth::AST If::trim_start() const { return node->Attr("trim_start"); }

inline alioth::AST Iter::anchor() const { return node->Attr("anchor"); }
inline std::vector<alioth::AST> Iter::fragments() const { return node->Attrs("fragments"); }
inline alioth::AST Iter::index() const { return node->Attr("index"); }
inline Expr Iter::iter() const { return node->Attr("iter")->template As<Expr>(); }
inline alioth::AST Iter::key() const { return node->Attr("key"); }
inline alioth::AST Iter::trim_end() const { return node->Attr("trim_end"); }
inline alioth::AST Iter::trim_start() const { return node->Attr("trim_start"); }
inline alioth::AST Iter::value() const { return node->Attr("value"); }

inline std::vector<alioth::AST> Overwrite::fragments() const { return node->Attrs("fragments"); }
inline alioth::AST Overwrite::overwrite() const { return node->Attr("overwrite"); }
inline alioth::AST Overwrite::trim_start() const { return node->Attr("trim_start"); }

inline std::vector<alioth::AST> Template::fragments() const { return node->Attrs("fragments"); }

inline alioth::AST Text::text() const { return node->Attr("text"); }

inline alioth::AST This::key() const { return node->Attr("key"); }
inline Expr This::value() const { return node->Attr("value")->template As<Expr>(); }



}

#endif