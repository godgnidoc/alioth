/**
 * @note This parser header file is generated from a template.
 * Any modifications to this file will be overwritten.
 * Please do not edit this file directly.
 *
 * @note 此文件是从模板生成的。
 * 任何对该文件的修改都将被覆盖。
 * 请不要直接编辑此文件。
 */

#ifndef __ANNOTATE_SYNTAX_H__
#define __ANNOTATE_SYNTAX_H__

#include "alioth/ast.h"
#include "assignment/syntax.h"


namespace annotate {

constexpr alioth::SymbolID COLON = 1;
constexpr alioth::SymbolID LANG = 2;
constexpr alioth::SymbolID ID = 3;
constexpr alioth::SymbolID COMMENT = 4;
constexpr alioth::SymbolID SPACE = 5;

struct Annotate; // SymbolID = 7; Accepts: [7]


using Assignment = ::assignment::Assignment;


struct Annotate {
  std::vector<Assignment> assignments() const;
  alioth::AST lang() const;
  alioth::AST node{};

  operator alioth::AST() const { return node; }
  operator bool() const { return node != nullptr; }
  alioth::ASTNode* operator->() const { return node.get(); }
  alioth::ASTNode& operator*() const { return *node; }
};


}

namespace alioth {
template<>
inline annotate::Annotate alioth::ASTNode::As<annotate::Annotate>() {
  switch(id) {
    case 7:
    return annotate::Annotate{shared_from_this()};
  default:
    return {};
  }
}


template<>
inline Syntax SyntaxOf<annotate::Annotate>() {
  static auto syntax = []{
    using namespace nlohmann;
    auto lex = Lexicon::Builder("annotate");
    lex.Define("COLON", R"(:)"_regex);
    
    lex.Define("LANG", R"(lang)"_regex, { "keyword",  });
    
    lex.Define("ID", R"([a-zA-Z_]\w*)"_regex);
    
    lex.Define("COMMENT", R"(#[^\n]*\n)"_regex);
    lex.Annotate("COMMENT", "tokenize", R"({"type":"comment"})"_json);
    
    lex.Define("SPACE", R"(\s+)"_regex);
    
    
    auto syntax = Syntactic::Builder(lex.Build());
    syntax.Ignore("COMMENT");
    syntax.Ignore("SPACE");
    
    syntax.Import(::alioth::Syntax<::assignment::Assignment>(), "assignment");
    syntax.Formula("annotate").Symbol("LANG").Symbol("COLON").Symbol("ID", "lang").Symbol("assignments", "...").Commit();
    syntax.Formula("assignments").Symbol("assignment", "assignments").Commit();
    syntax.Formula("assignments").Symbol("assignments", "...").Symbol("assignment", "assignments").Commit();
    
    return syntax.Build();
  }();

  return syntax;
}
}

namespace annotate {

inline std::vector<Assignment> Annotate::assignments() const { 
  return alioth::generic::collect<alioth::generic::multiple>(
    node->Attrs("assignments"), 
    [](auto n) {
      return n->template As<Assignment>();
    }
  );
}
inline alioth::AST Annotate::lang() const { 
  return node->Attr("lang");
}



}

#endif