# `grammar` 文法

`grammar` 文法供开发人员以人类可读的文本形式定义可以支持属性树构建的词法规则和语法规则。本文介绍 `grammar` 文法的结构和语义。

> `grammar` 文法的正规定义参见 [grammar.grammar](/grammar/grammar.grammar)

## 1.1. 全文结构

`grammar` 文法由三个主要部分构成：

1. 参数定义：用于定义一些供解析器使用的 `json` 参数
2. 词法定义：定义全部终结符的正则表达式和上下文
3. 语法定义：定义全部语法结构的产生式

上述三个部分均不可省略，且顺序不能错乱。

## 1.2. 注释

任意单词之间均可以插入注释，`grammar` 仅支持一种由 `#` 领起直到行尾结束的单行注释。

```
# 此为合法注释，直到此行结束
```

## 1.2. 参数定义

参数定义由参数名和参数值构成，使用 `:` 连接。参数名满足 `C` 风格标识符规则，参数值为 `json` 值。

```
# 下述参数定义均合法

lang: "my_language"
my_number: 3.1415926
my_array: ["a", "b", "c"]
my_object: {
    "anything": "中文也可以"
    "boolean": true,
    "null": null
}
```

### 1.2.1. lang 选项

当前版本要求文法至少定义一个 `lang` 参数。其值为字符串，表示当前文法所定义的语言的名称。

`lang` 参数作为语言名称，还意味着以下条件的成立：

- 词法规则中的默认上下文名称使用 `lang` 参数。
- 语法分析树根的唯一属性以 `lang` 参数的值命名。

## 1.3. 词法规则

词法规则由单词名称和正则表达式构成，中间用 `=` 连接。

```
T_ID = /[a-zA-Z_]\w*/
T_DIGIT = /\d+/
```

由词法规则定义的单词，按照书写顺序会由小到大获得单词`ID`，第一个单词`ID`为 `1`，第二个单词ID为 `2` 以此类推。

`alioth` 词法分析器总是尝试匹配更长的单词，若一段文本最终可以匹配多个长度相同的单词，则词法分析器以其中`ID`最小者为准。

### 1.3.1. 正则表达式

`Alioth` 正则表达式由一对正斜杠包含，不能跨行。

> TODO: 补充对正则表达式各语法结构的描述

### 1.3.2. 上下文

可选地，可以在单词名后面插入一组由尖括号包含的上下文名表，表示此单词仅在指定的上下文被分析。

```
T_IN<operator> = /in/
T_ID = /[a-zA-Z_]\w*/
```

默认情况下，不定义上下文列表的单词在任何上下文均有效。

若当前状态的展望单词定义在不同的多个上下文中，`alioth` 语法分析器会针对每个上下文创建分歧处理分支继续分析文本。这意味着巧妙定义单词所在的上下文可以帮助语法分析器区分一些书写形式相同，但语义不同的单词。

### 1.3.3. 可忽略单词

在 `=` 之前添加一个 `?` 可以定义一个可忽略单词。

如果语法分析器尝试移进和归约一个单词均失败之后，我们要祈祷它是一个可忽略单词，否则语法分析器会报告一个语法错误。

```
SPACES ?= /\s+/
COMMENT ?= /#[^\n]*\n/
```

可忽略单词在归约阶段被剔除句子结构，以避免干扰语法分析和属性提取。待一切尘埃落定，分析器会将被忽略的可忽略单词按照书写顺序正确回填到句子结构。这是为了照顾 `Tokenize` 功能不能丢弃任何一个单词的决心。

## 1.4. 语法规则

语法规则部分定义每一种非终结符节点的语法结构。语法结构非终结符名和产生式构成，中间使用 `->` 连接，最后以 `;` 结束。

```
branch -> T_IF T_OPEN expr T_CLOSE stmt;
```

### 1.4.1. 产生式组

若某一种非终结符拥有多种句子结构，可以将多条产生式合并为产生式组，使用 `|` 连接。

```
define -> T_DEF T_ID
    | T_DEF T_ID T_ASSIGN expr;
```

### 1.4.2. 可省符号

我们可以在某个符号后面追加一个 `?` 表示这个符号可有可无。实际上这是对拥有此符号和不拥有此符号的两组产生式的简写。

```
param -> T_ID T_OPTIONAL?;
```

下列语法规则与上述定义等价。

```
param -> T_ID
    | T_ID T_OPTIONAL;
```

### 1.4.3. 具名属性

终于来到这个部分了，`grammar` 文法允许定义带有综合属性标记的语法规则，以便分析器在构建语法分析树的同时构建一棵仅由属性节点构成的属性树。

在产生式的某个符号后面追加`@`和一个属性名可以将此符号标记为当前非终结符节点的一个属性。

```
define -> T_DEF T_ID@name
    | T_DEF T_ID@name T_ASSIGN expr@init;
```

同名属性可以出现多次，此属性会被分析为一个列表，其中按照书写顺序包含全部被标记为此属性的符号。

### 1.4.4. 展开属性

某些情况下，我们会定义一些嵌套的语法结构用来解决歧义问题。但在语义分析的角度审视它们，并不能将他们分割为不同的层次看待。

在产生式的某个符号之前添加 `...` 表示将此符号所携带的全部属性表合并到当前非终结符节点上。

```
function -> T_ID@name T_OPEN ...params T_CLOSE;
params -> param@params
    | ...params T_COMMA param@params;
```

### 1.4.5. 句型分组

有些语法结构非常复杂，需要很多产生式来定义各种书写形式。而众多书写形式又可以以某种视角归类。我们在非终结符名后面追加一个`.`和句型分组名。表示这一组定义的全部产生式被归纳到指定句型组。

```
expr.binary -> expr@lhs T_ADD@op expr@rhs
    | expr@lhs T_SUB@op expr@rhs;
expr.mono -> T_SUB@op expr@rhs;
```

句型分组不影响语法分析算法的任何行为，它主要用于在骨架推理阶段将语法结构的属性结构做进一步细分，有助于生成更便于使用的框架代码。

### 1.4.6. 展开产生式

具备如下特征的产生式被称为(完全)展开产生式：

- 产生式不具备句型分组
- 产生式只有一个展开符号

展开产生式有很多特殊意义：

- 展开产生式会向产生式头传递属性
- 展开产生式会向产生式头传递句型分组

### 1.4.7. 空产生式

如果你需要定义一个不包含任何单词的产生式，可以使用 `%empty` 作为产生式中唯一的单词：

```
body -> %empty;
body -> ...body stmt;
```