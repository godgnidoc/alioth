# template 模板引擎介绍

`Python` 中的 `Jinja` 模板引擎非常强大，令人向往。`alioth` 项目希望引入一种模板引擎用于生成客户语言的骨架代码。

但 `alioth` 项目致力于在最少的外部依赖实现必备功能，我们思前想后认为引入 python 作为功能基础还是不妥。

而 `C++` 社区中的两个 `Jinja` 实现 `Jinja2Cpp` 和 `Jinja2CppLight` 前者功能强大但依赖体量也大。而后者的功能体量可能不够实现复杂的骨架生成。

所以，`alioth` 基于内建的 `Grammar` 文法设计了 `Template` 模板语法，

> 参见 [template.grammar](/grammar/template.grammar) 可以获得语法定义。
> 得益于 Grammar 的歧义处理能力，`Template` 的关键字被定义得非常干净，对小拇指很友好.  
> 减少了左手shift+左手字符的情况，对没错，说的就是 '%'

本文将从模板引擎和模板语言两个角度讲解 `template` 的使用方法和设计细节。

- [template 模板引擎介绍](#template-模板引擎介绍)
  - [模板语言](#模板语言)
    - [表达式演算](#表达式演算)
    - [分支判断](#分支判断)
    - [容器迭代](#容器迭代)
    - [继承与覆写](#继承与覆写)
    - [调用](#调用)
    - [注释](#注释)
  - [模板引擎](#模板引擎)

## 模板语言

### 表达式演算

在 `Template` 中可以将变量或表达式的演算结果插入文本，这是模板引擎的基础功能。

`Template` 支持变量引用、成员解析和下标运算以及管道运算：

```
字面字符串和字面数字 {{ "this is string" }} {{ -3.1415926e3 }}
引用变量 var {{ var }}
一个复杂的下标和成员混合表达式 {{ array[1][2].member[myIndex] }}
调用函数，支持0或多个参数 {{ group.func(expr1, expr2) }}
管道运算将一个或多个过滤器顺次应用到文本 {{ "Hello world" | lowercase | remove_prefix("hello ") }}
```

### 分支判断

在 `Template` 中可以依据某些表达式的演算结果来选择要生成的文本。

分支语句由 `{{ if cond }}` 领起，由 `{{ end if }}` 终止。

分支语句中可以按顺序添加若干个 `{{ else if cond }}` 块，以及最后可选地的一个 `{{ else tnen}}` 块：

```
{{ if mycond }}
这是外层成立分支
{{ else if second_cond }}
这是外层第一个备选分支
{{ else if third_cond }}
这是外层第二个备选分支
    {{if inner }}
    这是内层成立分支
    {{ end if }}
{{ else then }}
这是外层最后的备选分支
{{ end if }}
```

在条件判断中：

- 布尔值直接参与判断，
- 空的容器和空值以及等于0的数值均被判定为假，
- 其它情况均判定为真

### 容器迭代

在 `Template` 中可以迭代容器，为容器中的每个元素都生成一次指定的文本。在迭代时，要为当前容器元素拟定一个临时变量名。此外，可选地还可以为当前元素在容器中的键和元素拟定变量名以便使用。

```
{{ for value in array }}
...
{{ end for }}

{{ for value, key in object }}
...
{{ end for }}

{{ for value, key, index in something }}
...
{{ end for }}
```

在迭代时，可以为当前迭代上下文命名，之后可以从具名的迭代上下文中获取边界状态用于简便判断：

```
{{ for@here value in array }}
  {{ if first@here }} The first value is {{ value }} {{ end if }}
  {{ if last@here }} The last value is {{ value }} {{ end if }}
  {{ if nonfirst@here }} The value {{ value }} is not first {{ end if }}
  {{ if nonlast@here }} The value {{ value }} is not last {{ end if }}
{{ end for }}
```

### 继承与覆写

在 `Template` 模板中，可以定义一些具有名字的 `block`，当其它模板继承当前模板时，可以选择其中一些块来覆写：

```
这里是模板的模板
{{ block first }}
这是第一个块的默认内容，若不覆写，则应用此处内容
{{ end block }}

一些其他文本

{{ block first }}
这是第一个块的默认内容，若不覆写，则应用此处内容
{{ end block }}
```

上述样例定义了两个块，如果没人覆写的话，其中原本的内容就会被应用。

```
{{ extends "./another.template" }}

{{ overwrite first }}
这里是覆写第一个块的内容
{{ end overwrite }}
```

上述模板使用 `extends` 语句指定了当前模板继承的模板。并在后文中使用 `overwrite` 语句块覆写了其中定义的一个块。另一个未被覆写的块将保持原始定义被输出。

### 调用

模板之间可以相互调用，调用模板时默认会传入当前模板正在使用的模型作为输入。您可以指定一个表达式的演算结果作为被调用的模板的输入模型。

```
使用当前模型调用一个外部模板 {{ call "./another.template" }}

使用一个表达式的值调用外部模板 {{ call "./some.template" with my_variable }}
```

### 注释

在语句块之间，可以插入注释块，注释块会在渲染文本时被剔除。

```
{{ -- 这里是注释 }}
{{ -- 注释可以跨行
      这里是第二行}}
```

## 模板引擎

模板引擎的 `Render` 接口用于指定一个模板，将用户提供的数据模型渲染为文本。

`alioth` 模板引擎的工作原理是将指定的模板源码编译为 `Filter` 对象。`Filter` 是一种可以工作在 `Context` 上的仿函数，定义如下：

```C++
using Filter = std::function<Value(Context& ctx, Array const& args)>;
```
其中 `Value` 是模板引擎中重要的统一抽象，可用于表示

- 空值 `nullptr_t`，
- 字符串 `String` ，
- 数字 `Number` 和 `Integer`，
- 布尔值 `Boolean`，
- 数组 `Array`，
- 映射表 `Map`，
- 乃至过滤器 `Filter`。

`Value` 抽象统一了 `Filter` 和其它数据结构的地位，这允许我们通过任意复杂的表达式获得一个 `Filter` 并将其作为一个函数调用或作为一个管道串接。

`Render` 接口会创建 `Context` 对象为 `Filter` 提供运行时环境，主要包含三个部分：

- 模板缓冲表，在模板相互调用或继承时登记复用已编译产生的 `Filter` 减少开销。
- 调用栈，为迭代、调用和继承等语法提供独立的变量作用域。
- 元信息表，相当于全局变量表和全局函数表，不受调用栈影响，通常用于提供基础工具箱。

框架会将用户传入的模型用作第一层调用栈的变量表。进入迭代、调用和继承语法时框架会产生新的栈帧，为当前语法结构保存局部变量表。

栈帧除了保存变量表以外，还可能保存一个当前模板的路径，用于支持模板可能通过相对路径调用或继承其它模板的情况。只有加载新的模板产生的栈帧拥有模板路径，这样的栈帧被称为逻辑栈底。

逻辑栈底的作用是标记一个局部作用域可能到此为止，配合一个透明标志使用。

`call` 语句可以指示模板引擎复用当前模型，此时产生的栈帧是透明栈帧。反之若 `call` 语句显式指定了新模板要使用的模型，则产生一个不透明的逻辑栈帧。

模板中的变量表达式沿着调用栈逆序遍历栈帧，在每个栈帧的变量表上查找指定变量。若查找过程遭遇一个不透明栈帧，则应当结束查找，避免外层模板的运行环境干扰被调模板的调用栈。

若查找遭遇了一个透明栈帧，则应当直接跳跃到下一个不透明栈帧做最后一次查找。即复用当前模型，但不能被当前调用栈干扰被调模板。

若在任何调用栈帧都没找到指定变量，则尝试从元信息表查找指定变量。