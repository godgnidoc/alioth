# 分析器算法介绍

`alioth` 提供一个通用的 `Parser` 分析器，可以导入任意语法规则执行词法分析和语法分析任务。本文介绍 `Parser` 分析器中值得关注的设计细节。

首先，类似于 `flex`中的入口点概念，词法分析器支持`context`用于将匹配相同文本的不同词法规则隔离到不同的上下文中。

语法分析器是一个简化版的 `GLR` 分析器，由 `LR(1)` 分析表驱动。若当前展望符号分属于多个不同的上下文，语法分析器会创建分析分支进入每个上下文分别继续分析文本。

通常语法分析器构建的完整语法分析树包含大量不携带语义的单词节点。语义分析算法要小心排除这些单词的干扰才能顺利运行。

`alioth` 提供 `grammar` 文法可以在产生式中通过综合属性标记真正携带语义的符号。分析器会在构建语法分析树的同时依据属性标记构建出一棵仅包含重要节点的属性树。属性树更适合用作语义分析算法的输入结构。

## 1. 分歧处理

### 1.1. 向DFA引入上下文

`alioth` 词法分析器生成器依据 `followpos` 计算从正则表达式产生确定有穷状态机。

`Lexical::Builder` 在开始扫描全部真正 `followpos` 之前，先产生一个 `0` 状态。

再为每个上下文分别创建一个入口状态，使用上下文 `id` 作为预期输入，在各个上下文入口状态与 `0` 状态之间建立跳转规则。

接下来，算法会将每个单词的正则表达式的 `firstpos` 登记到其所处的上下文对应的状态上。

后续算法只需继续按照原算法反复计算每个状态的 `followpos`，按需创建新的状态登记跳转和接受规则即可。

### 1.2. 归纳展望上下文

语法分析表构建算法大致遵循 `LR(1)` 分析表的构建算法。只是在每个状态上添加了一个上下文表用于指导分析器开创分析分支。

全部状态创建完毕后，算法会迭代每个状态上的归约规则和移进规则所期待的输入符号，将他们所属的上下文归纳到状态的上下文表。

### 1.3. 分析线路的维护

分析线路的维护重点在于何时产生和销毁分析线路。每条分析线路保存了当前的文本偏移量和这条线路上的 `LR` 语法分析器格局。

语法分析器总是批量处理全部分析线路，每一轮操作迭代全部线路，各做一个动作。

在每轮迭代开始之前，分析器会统一尝试为每个分析线路获取下一个输入。若某个分析线路当前的输入队列为空，则进入词法分析过程。

在词法分析过程，可分为两种情况考虑。大部分情况下，当前格局的展望上下文只有一个。此时算法直接沿用当前分析线路进入指定上下文分析一个单词。

若当前分析线路的展望上下文有多个，则迭代全部上下文，第一个上下文复用原分析线路，其它上下文则本别从当前线路克隆产生新的分析线路继续分析。

每轮迭代结束后，进入清理过程，将已接受或已报错的分析线路清理掉。

## 2. 语法树简化

### 2.1. 属性标记

`grammar` 文法允许在产生式体的符号后面使用 `@` 定义一个名称。此类标记类似于综合属性定义，姑且称之为属性标记。

### 2.2. 属性展开

在产生式体的符号前面添加 `...` 表示展开属性，即将指定符号所拥有的全部属性合并到当前语法结构的属性表。

### 2.3. 属性表建立

由上述两种标记可知，我们的属性表实际上存储的是语法树节点，也可以理解为语法树子树。每个语法树节点都包含自己的句子符号串和属性表。

假设在一次迭代中，我们只关注根节点和每一个节点的属性表，则我们将得到一棵规模比语法树更小，仅包含重要子树的属性树。

属性表的建立过程也很简单，在每次触发归约动作时，分析器能够找到归约要使用的产生式。

首先依据产生式体的符号个数从栈中弹出相应个数的符号构成当前子树的句子符号串。之后再同时迭代产生式符号定义和句子符号串找到具名属性或展开属性，将他们填写到属性表即可。

### 2.4. 可忽略符号

上述算法对句子串中符号的相对位置要求很高，若句子串中出现了意料之外的单词，就会导致属性表分析错误。

而诸如注释和空白符这类的单词，需要被词法分析器正确识别，却不能参与语法分析和属性提取。

`alioth` 允许在这样的单词定义语句上添加一个 `?` 表示这个单词可忽略。当尝试输入一个可忽略单词执行归约或移进操作均失败后，这个单词会被忽略。这样我们就不需要反复在产生式中提及我们不需要的单词了。

被忽略的单词不能被立刻丢弃，因为如果我们的任务是对全部单词做语义化词法高亮，则我们仍需要能在语法树数据结构上找到全文真实存在的每个单词。

由此，被忽略的单词会被加入到一个类似移进符号栈的队列中。每次触发归约操作后，待全部属性均分析完毕后，算法会扫描忽略单词表，将熟悉位置被当前语法结构涵盖的单词都填写到句子串的对应位置上。